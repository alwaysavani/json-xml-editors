<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON/XML Form Editor</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Font: Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            /* Light pinkish background */
            background-color: #fce7f3; /* very light pink */
        }
        /* Custom scrollbar for textareas */
        textarea::-webkit-scrollbar {
            width: 8px;
        }
        textarea::-webkit-scrollbar-track {
            background: #fbcfe8; /* light pink */
            border-radius: 4px;
        }
        textarea::-webkit-scrollbar-thumb {
            background: #db2777; /* dark pink */
            border-radius: 4px;
        }
        textarea::-webkit-scrollbar-thumb:hover {
            background: #be185d; /* darker pink */
        }

        /* Basic styling for collapsible sections */
        .collapsible-header {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            /* Light pink-purple background */
            background-color: #fbcfe8; /* light pink */
            border-radius: 0.5rem;
            margin-bottom: 4px;
            font-weight: 600;
            color: #831843; /* dark pink text */
        }
        .collapsible-header:hover {
            background-color: #f9a8d4; /* slightly darker pink */
        }
        .collapsible-content {
            display: none; /* Hidden by default */
            padding-left: 1rem;
            /* Light gray border for visual nesting, matching new theme */
            border-left: 2px solid #fbcfe8; /* light pink border */
            margin-left: 0.5rem;
        }
        .collapsible-header.active + .collapsible-content {
            display: block;
        }
        .collapsible-arrow {
            transition: transform 0.2s ease-in-out;
        }
        .collapsible-header.active .collapsible-arrow {
            transform: rotate(90deg);
        }
    </style>
</head>
<body class="p-6 flex flex-col items-center min-h-screen">
    <div class="container bg-white shadow-lg rounded-xl p-8 max-w-6xl w-full"> <!-- Increased max-width for side-by-side -->
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">JSON/XML Form Editor</h1>

        <!-- Message Box for errors/info - moved before content sections -->
        <div id="messageBox" class="hidden px-4 py-3 rounded-lg relative mb-6" role="alert">
            <strong class="font-bold" id="messageBoxTitle"></strong>
            <span class="block sm:inline" id="messageText"></span>
        </div>

        <div class="flex flex-col md:flex-row md:space-x-8"> <!-- Flex container for side-by-side layout -->
            <!-- Input Section -->
            <div class="w-full md:w-1/2 mb-8 md:mb-0"> <!-- Adjusted width and removed bottom margin for desktop -->
                <label for="dataInput" class="block text-gray-700 text-sm font-semibold mb-2">Paste JSON or XML here:</label>
                <textarea id="dataInput" rows="15" class="w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-pink-500 transition duration-200 resize-y" placeholder='Paste your JSON (e.g., {"name": "Alice", "age": 30}) or XML (e.g., <person><name>Bob</name><age>25</age></person>) here...'></textarea>
                <div class="flex justify-center mt-4 space-x-4">
                    <button id="processInputBtn" class="bg-pink-600 hover:bg-pink-700 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-opacity-75">
                        Process Input
                    </button>
                    <button id="prettifyBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-3 px-6 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75">
                        Prettify Input
                    </button>
                </div>
            </div>

            <!-- Form Display Section - now always visible -->
            <div id="formContainer" class="w-full md:w-1/2 p-6 border border-gray-200 rounded-lg bg-gray-50 overflow-y-auto max-h-[70vh]">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4 text-center">Editable Form</h2>
                <div id="dynamicForm">
                    <!-- Form fields will be dynamically generated here -->
                    <p class="text-gray-500 text-center py-4">Paste data on the left and click "Process Input" to see the form here.</p>
                </div>
                <div class="flex flex-wrap justify-center mt-6 space-x-2 space-y-2">
                    <button id="downloadJsonBtn" class="bg-pink-700 hover:bg-pink-800 text-white font-semibold py-3 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-pink-600 focus:ring-opacity-75">
                        Download JSON
                    </button>
                    <button id="copyJsonBtn" class="bg-pink-800 hover:bg-pink-900 text-white font-semibold py-3 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-pink-700 focus:ring-opacity-75">
                        Copy JSON
                    </button>
                    <button id="downloadXmlBtn" class="bg-pink-700 hover:bg-pink-800 text-white font-semibold py-3 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-pink-600 focus:ring-opacity-75">
                        Download XML
                    </button>
                    <button id="copyXmlBtn" class="bg-pink-800 hover:bg-pink-900 text-white font-semibold py-3 px-4 rounded-lg shadow-md transition duration-200 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-pink-700 focus:ring-opacity-75">
                        Copy XML
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const dataInput = document.getElementById('dataInput');
        const processInputBtn = document.getElementById('processInputBtn');
        const prettifyBtn = document.getElementById('prettifyBtn');
        const formContainer = document.getElementById('formContainer');
        const dynamicForm = document.getElementById('dynamicForm');
        const downloadJsonBtn = document.getElementById('downloadJsonBtn');
        const copyJsonBtn = document.getElementById('copyJsonBtn');
        const downloadXmlBtn = document.getElementById('downloadXmlBtn');
        const copyXmlBtn = document.getElementById('copyXmlBtn');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageBoxTitle = document.getElementById('messageBoxTitle');


        let currentParsedData = null; // Stores the parsed JSON/XML object
        let currentDataType = null; // 'json' or 'xml'

        /**
         * Displays a message in the message box.
         * @param {string} message The message to display.
         * @param {string} type 'success' or 'error'.
         */
        function showMessage(message, type) {
            messageText.textContent = message;
            if (type === 'error') {
                messageBox.className = 'bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-6';
                messageBoxTitle.textContent = 'Error!';
            } else {
                messageBox.className = 'bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded-lg relative mb-6';
                messageBoxTitle.textContent = 'Success!';
            }
            messageBox.classList.remove('hidden');
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 5000); // Hide after 5 seconds
        }

        /**
         * Clears the dynamic form and hides the form container.
         * Now it just clears the content, as the container is always visible.
         */
        function clearForm() {
            dynamicForm.innerHTML = '<p class="text-gray-500 text-center py-4">Paste data on the left and click "Process Input" to see the form here.</p>';
            currentParsedData = null;
            currentDataType = null;
        }

        /**
         * Toggles the visibility of a collapsible section.
         * @param {Event} event The click event.
         */
        function toggleCollapsible(event) {
            const header = event.currentTarget;
            const content = header.nextElementSibling;
            if (content) {
                header.classList.toggle('active');
                if (content.style.display === 'block') {
                    content.style.display = 'none';
                } else {
                    content.style.display = 'block';
                }
            }
        }

        /**
         * Creates an input field for a given key and value.
         * @param {string} key The key/label for the input.
         * @param {any} value The initial value for the input.
         * @param {string} path The dot-separated path to the element in the data structure.
         * @returns {HTMLElement} The div containing the label and input.
         */
        function createInputField(key, value, path) {
            const div = document.createElement('div');
            div.className = 'mb-2';

            const label = document.createElement('label');
            label.textContent = `${key}:`;
            label.className = 'block text-gray-700 text-sm font-medium mb-1';
            label.setAttribute('for', `input-${path}`);
            div.appendChild(label);

            const input = document.createElement('input');
            input.id = `input-${path}`;
            input.className = 'w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-1 focus:ring-pink-400 text-gray-800';
            input.value = value !== null && value !== undefined ? value : '';
            input.dataset.path = path; // Store path for easy updates
            input.dataset.key = key; // Store key for XML attribute handling

            // Determine input type
            if (typeof value === 'boolean') {
                input.type = 'checkbox';
                input.checked = value;
                input.className = 'mr-2 leading-tight'; // Adjust styling for checkbox
                div.classList.add('flex', 'items-center', 'mb-2'); // Align checkbox and label
                div.removeChild(label); // Remove original label
                div.appendChild(input);
                div.appendChild(label); // Put label after checkbox
            } else if (typeof value === 'number' && !isNaN(value)) {
                input.type = 'number';
            } else {
                input.type = 'text';
            }

            input.addEventListener('input', updateCurrentData);
            div.appendChild(input);
            return div;
        }

        /**
         * Updates the global currentParsedData object based on input field changes.
         * This function handles both JSON and XML updates.
         * @param {Event} event The input event from a form field.
         */
        function updateCurrentData(event) {
            const input = event.target;
            let path = input.dataset.path.split('.');
            let value;

            if (input.type === 'checkbox') {
                value = input.checked;
            } else if (input.type === 'number') {
                value = parseFloat(input.value);
                if (isNaN(value)) { // If input is not a valid number, keep as string or revert
                    value = input.value;
                }
            } else {
                value = input.value;
            }

            if (currentDataType === 'json') {
                let current = currentParsedData;
                for (let i = 0; i < path.length - 1; i++) {
                    const key = path[i];
                    if (Array.isArray(current) && !isNaN(parseInt(key))) { // If array, parse index
                        current = current[parseInt(key)];
                    } else {
                        current = current[key];
                    }
                    if (!current) {
                        console.error('Path not found in JSON:', path.slice(0, i + 1).join('.'));
                        return;
                    }
                }
                const lastKey = path[path.length - 1];
                if (Array.isArray(current) && !isNaN(parseInt(lastKey))) {
                    current[parseInt(lastKey)] = value;
                } else {
                    current[lastKey] = value;
                }
            } else if (currentDataType === 'xml') {
                let current = currentParsedData;
                let nodePath = []; // To navigate the actual DOM structure of XML document
                let attributePath = null;

                // Separate attributes from element path
                if (path[path.length - 1].startsWith('@')) {
                    attributePath = path.pop().substring(1); // Remove '@'
                }

                // Navigate through XML nodes
                for (let i = 0; i < path.length; i++) {
                    const segment = path[i];
                    if (segment.startsWith('__array_item_')) {
                        // For array-like XML structures, the segment will be like __array_item_0, __array_item_1
                        // We need to find the correct child node by tag name and index
                        const tagName = segment.substring(segment.indexOf('_item_') + 6); // Extract the original tag name if it was part of index
                        const index = parseInt(segment.substring(segment.indexOf('_item_') + 6));

                        // Find the child node by its tag name (or just index if it's a direct child)
                        let foundNode = null;
                        if (current.children && current.children.length > index) {
                            foundNode = current.children[index];
                        }

                        if (!foundNode) {
                            console.error('XML node not found at path segment:', segment);
                            return;
                        }
                        current = foundNode;

                    } else {
                        // For regular element names
                        const children = Array.from(current.children);
                        const nextNode = children.find(child => child.nodeName === segment);
                        if (nextNode) {
                            current = nextNode;
                        } else {
                            // This path segment doesn't match a direct child, it might be an array element
                            // If segment is numeric, it's an array index
                            const numIndex = parseInt(segment);
                            if (!isNaN(numIndex) && current.children && current.children.length > numIndex) {
                                current = current.children[numIndex];
                            } else {
                                console.error('XML node not found at path segment:', segment);
                                return;
                            }
                        }
                    }
                }

                if (attributePath) {
                    current.setAttribute(attributePath, value);
                } else {
                    // Update text content of the element
                    current.textContent = value;
                }
            }
        }


        /**
         * Builds the form for JSON data.
         * @param {object | array} data The JSON data.
         * @param {HTMLElement} parentElement The DOM element to append to.
         * @param {string} currentPath The current dot-separated path.
         */
        function buildJsonForm(data, parentElement, currentPath = '') {
            if (typeof data !== 'object' || data === null) {
                // This case should ideally be handled by the parent caller for primitive values
                return;
            }

            if (Array.isArray(data)) {
                data.forEach((item, index) => {
                    const itemPath = `${currentPath}.${index}`;
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'border-l-2 border-pink-200 pl-4 py-2 my-2 bg-pink-50 rounded-md';
                    const header = document.createElement('div');
                    header.className = 'collapsible-header bg-pink-200 text-pink-800 rounded-md p-2 mb-2 hover:bg-pink-300';
                    header.innerHTML = `<span>Item ${index + 1}</span><span class="collapsible-arrow">></span>`;
                    header.addEventListener('click', toggleCollapsible);
                    itemDiv.appendChild(header);

                    const content = document.createElement('div');
                    content.className = 'collapsible-content';
                    itemDiv.appendChild(content);

                    if (typeof item === 'object' && item !== null) {
                        buildJsonForm(item, content, itemPath);
                    } else {
                        // Primitive array item
                        content.appendChild(createInputField(`Value`, item, itemPath));
                    }
                    parentElement.appendChild(itemDiv);
                });
            } else {
                // It's an object
                for (const key in data) {
                    if (Object.prototype.hasOwnProperty.call(data, key)) {
                        const value = data[key];
                        const newPath = currentPath ? `${currentPath}.${key}` : key;

                        if (typeof value === 'object' && value !== null) {
                            const sectionDiv = document.createElement('div');
                            sectionDiv.className = 'mb-4 border border-gray-200 rounded-lg p-4 bg-white';
                            const header = document.createElement('div');
                            header.className = 'collapsible-header bg-gray-100 text-gray-800 hover:bg-gray-200';
                            header.innerHTML = `<span>${key}</span><span class="collapsible-arrow">></span>`;
                            header.addEventListener('click', toggleCollapsible);
                            sectionDiv.appendChild(header);

                            const content = document.createElement('div');
                            content.className = 'collapsible-content';
                            sectionDiv.appendChild(content);

                            buildJsonForm(value, content, newPath); // Recurse
                            parentElement.appendChild(sectionDiv);
                        } else {
                            // Primitive value
                            parentElement.appendChild(createInputField(key, value, newPath));
                        }
                    }
                }
            }
        }


        /**
         * Builds the form for XML data.
         * @param {Element} node The current XML DOM node.
         * @param {HTMLElement} parentElement The DOM element to append to.
         * @param {string} currentPath The current dot-separated path.
         */
        function buildXmlForm(node, parentElement, currentPath = '') {
            // Handle attributes first
            if (node.attributes && node.attributes.length > 0) {
                const attributesDiv = document.createElement('div');
                attributesDiv.className = 'mb-2 border-b border-gray-200 pb-2';
                const attributesHeader = document.createElement('div');
                attributesHeader.className = 'text-gray-600 text-sm font-semibold mb-1';
                attributesHeader.textContent = `Attributes for <${node.nodeName}>:`;
                attributesDiv.appendChild(attributesHeader);

                Array.from(node.attributes).forEach(attr => {
                    const attrPath = `${currentPath}.@${attr.name}`;
                    attributesDiv.appendChild(createInputField(attr.name, attr.value, attrPath));
                });
                parentElement.appendChild(attributesDiv);
            }

            // Handle text content of the node itself (if any)
            const textContent = node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE ? node.childNodes[0].nodeValue.trim() : '';
            if (textContent) {
                const textPath = currentPath; // Path refers to the node itself for its text content
                parentElement.appendChild(createInputField(`${node.nodeName} Content`, textContent, textPath));
            }

            // Handle child elements
            if (node.children.length > 0) {
                // Group similar children to handle as potential arrays
                const childGroups = new Map(); // Map: tagName -> [elements]
                Array.from(node.children).forEach(child => {
                    if (!childGroups.has(child.nodeName)) {
                        childGroups.set(child.nodeName, []);
                    }
                    childGroups.get(child.nodeName).push(child);
                });

                childGroups.forEach((children, tagName) => {
                    if (children.length > 1) { // Array of elements with same tag name
                        const arraySectionDiv = document.createElement('div');
                        arraySectionDiv.className = 'mb-4 border border-pink-200 rounded-lg p-4 bg-pink-50';
                        const header = document.createElement('div');
                        header.className = 'collapsible-header bg-pink-200 text-pink-800 hover:bg-pink-300';
                        header.innerHTML = `<span>${tagName} (Array)</span><span class="collapsible-arrow">></span>`;
                        header.addEventListener('click', toggleCollapsible);
                        arraySectionDiv.appendChild(header);

                        const content = document.createElement('div');
                        content.className = 'collapsible-content';
                        arraySectionDiv.appendChild(content);

                        children.forEach((child, index) => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'border-l-2 border-pink-300 pl-4 py-2 my-2 bg-pink-100 rounded-md';
                            const itemHeader = document.createElement('div');
                            itemHeader.className = 'collapsible-header bg-pink-300 text-pink-900 rounded-md p-2 mb-2 hover:bg-pink-400';
                            itemHeader.innerHTML = `<span>${tagName} Item ${index + 1}</span><span class="collapsible-arrow">></span>`;
                            itemHeader.addEventListener('click', toggleCollapsible);
                            itemDiv.appendChild(itemHeader);

                            const itemContent = document.createElement('div');
                            itemContent.className = 'collapsible-content';
                            itemDiv.appendChild(itemContent);

                            // The path for an XML array item needs to reflect its position
                            // We use a pseudo-index in the path, e.g., 'path.to.tagName.__array_item_0'
                            // This ensures unique paths for children of the same tag name in an array context
                            const itemPath = `${currentPath}.${tagName}.__array_item_${index}`; // More robust path for XML arrays
                            buildXmlForm(child, itemContent, itemPath);
                            content.appendChild(itemDiv);
                        });
                        parentElement.appendChild(arraySectionDiv);

                    } else { // Single element
                        const child = children[0];
                        const sectionDiv = document.createElement('div');
                        sectionDiv.className = 'mb-4 border border-gray-200 rounded-lg p-4 bg-white';
                        const header = document.createElement('div');
                        header.className = 'collapsible-header bg-gray-100 text-gray-800 hover:bg-gray-200';
                        header.innerHTML = `<span>${child.nodeName}</span><span class="collapsible-arrow">></span>`;
                        header.addEventListener('click', toggleCollapsible);
                        sectionDiv.appendChild(header);

                        const content = document.createElement('div');
                        content.className = 'collapsible-content';
                        sectionDiv.appendChild(content);

                        const newPath = currentPath ? `${currentPath}.${child.nodeName}` : child.nodeName;
                        buildXmlForm(child, content, newPath); // Recurse
                        parentElement.appendChild(sectionDiv);
                    }
                });
            }
        }


        /**
         * Attempts to parse the input as JSON or XML and renders the form.
         */
        function processInput() {
            const inputText = dataInput.value.trim();
            clearForm(); // Clear previous form and data

            if (!inputText) {
                showMessage('Please paste some JSON or XML data.', 'error');
                return;
            }

            try {
                // Try parsing as JSON first
                const jsonData = JSON.parse(inputText);
                currentParsedData = jsonData;
                currentDataType = 'json';
                dynamicForm.innerHTML = ''; // Clear placeholder before building form
                buildJsonForm(jsonData, dynamicForm);
                showMessage('JSON data successfully converted to form.', 'success');
                // Ensure initial collapse state
                document.querySelectorAll('.collapsible-header').forEach(header => {
                    header.classList.remove('active');
                    if (header.nextElementSibling) {
                        header.nextElementSibling.style.display = 'none';
                    }
                });
                // Open top-level header if available
                const topLevelHeader = dynamicForm.querySelector('.collapsible-header');
                if (topLevelHeader) {
                    topLevelHeader.click(); // Programmatically click to open
                }

            } catch (jsonError) {
                // If JSON parsing fails, try XML
                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(inputText, 'text/xml');

                    // Check for parsing errors
                    const errorNode = xmlDoc.querySelector('parsererror');
                    if (errorNode) {
                        throw new Error(`XML parsing error: ${errorNode.textContent}`);
                    }

                    currentParsedData = xmlDoc.documentElement; // Get the root element
                    currentDataType = 'xml';
                    if (currentParsedData) {
                        dynamicForm.innerHTML = ''; // Clear placeholder before building form
                        buildXmlForm(currentParsedData, dynamicForm, currentParsedData.nodeName);
                        showMessage('XML data successfully converted to form.', 'success');
                        // Ensure initial collapse state
                        document.querySelectorAll('.collapsible-header').forEach(header => {
                            header.classList.remove('active');
                            if (header.nextElementSibling) {
                                header.nextElementSibling.style.display = 'none';
                            }
                        });
                        // Open top-level header if available
                        const topLevelHeader = dynamicForm.querySelector('.collapsible-header');
                        if (topLevelHeader) {
                            topLevelHeader.click(); // Programmatically click to open
                        }
                    } else {
                        showMessage('Could not parse XML: No document element found.', 'error');
                    }

                } catch (xmlError) {
                    showMessage(`Invalid JSON or XML. Please check your input. JSON Error: "${jsonError.message}". XML Error: "${xmlError.message}"`, 'error');
                }
            }
        }

        /**
         * Prettifies the JSON or XML content in the textarea.
         */
        function prettifyInput() {
            const inputText = dataInput.value.trim();
            if (!inputText) {
                showMessage('Nothing to prettify. Please paste some JSON or XML data.', 'error');
                return;
            }

            try {
                // Try prettifying as JSON
                const jsonData = JSON.parse(inputText);
                dataInput.value = JSON.stringify(jsonData, null, 2);
                showMessage('JSON prettified!', 'success');
            } catch (jsonError) {
                // If JSON fails, try XML
                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(inputText, 'text/xml');
                    const errorNode = xmlDoc.querySelector('parsererror');
                    if (errorNode) {
                        throw new Error(`XML parsing error: ${errorNode.textContent}`);
                    }
                    const serializer = new XMLSerializer();
                    // A simple way to pretty-print XML, might not be perfect for all cases
                    const prettyXml = formatXml(serializer.serializeToString(xmlDoc));
                    dataInput.value = prettyXml;
                    showMessage('XML prettified!', 'success');
                } catch (xmlError) {
                    showMessage(`Could not prettify. Invalid JSON or XML. JSON Error: "${jsonError.message}". XML Error: "${xmlError.message}"`, 'error');
                }
            }
        }

        /**
         * Simple XML formatter (stack overflow snippet adapted).
         * Not a full-fledged XML formatter, but adds indentation.
         * @param {string} xml The XML string to format.
         * @returns {string} The formatted XML string.
         */
        function formatXml(xml) {
            let formatted = '';
            const reg = /(>)(<)(\/*)/g;
            xml = xml.replace(reg, '$1\r\n$2$3');
            let pad = 0;
            xml.split('\r\n').forEach(node => {
                let indent = 0;
                if (node.match( /.+<\/\w[^>]*>$/ )) {
                    indent = 0;
                } else if (node.match( /^<\/\w/ )) {
                    if (pad != 0) {
                        pad -= 1;
                    }
                } else if (node.match( /^<\w[^>]*[^\/]>.*$/ )) {
                    indent = 1;
                } else {
                    indent = 0;
                }

                let padding = '';
                for (let i = 0; i < pad; i++) {
                    padding += '  ';
                }
                formatted += padding + node + '\r\n';
                pad += indent;
            });
            return formatted.trim();
        }


        // Event listeners
        processInputBtn.addEventListener('click', processInput);
        prettifyBtn.addEventListener('click', prettifyInput);


        /**
         * Initiates the file download.
         * @param {string} data The content to download.
         * @param {string} filename The name of the file.
         * @param {string} type The MIME type of the file.
         */
        function downloadFile(data, filename, type) {
            const blob = new Blob([data], { type: type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        /**
         * Copies text to the clipboard using document.execCommand.
         * @param {string} text The text to copy.
         */
        function copyToClipboard(text) {
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = text;
            // Make the textarea invisible and off-screen
            tempTextArea.style.position = 'fixed';
            tempTextArea.style.left = '-9999px';
            tempTextArea.style.top = '-9999px';
            document.body.appendChild(tempTextArea);
            tempTextArea.focus();
            tempTextArea.select();
            try {
                document.execCommand('copy');
                showMessage('Copied to clipboard!', 'success');
            } catch (err) {
                showMessage('Failed to copy to clipboard.', 'error');
                console.error('Copy command failed:', err);
            } finally {
                document.body.removeChild(tempTextArea);
            }
        }

        /**
         * Reconstructs JSON from the currentParsedData and triggers download.
         */
        downloadJsonBtn.addEventListener('click', () => {
            if (currentParsedData) {
                try {
                    let jsonString;
                    if (currentDataType === 'json') {
                        jsonString = JSON.stringify(currentParsedData, null, 2); // Pretty print
                    } else if (currentDataType === 'xml') {
                        // Convert XML DOM to JSON (simplified approach, might lose some XML nuances)
                        const jsonObject = xmlToJson(currentParsedData);
                        jsonString = JSON.stringify(jsonObject, null, 2);
                    }
                    downloadFile(jsonString, 'edited.json', 'application/json');
                } catch (e) {
                    showMessage('Error converting data back to JSON for download.', 'error');
                    console.error(e);
                }
            } else {
                showMessage('No data to download as JSON. Please process data first.', 'error');
            }
        });

        /**
         * Copies the current data as JSON to the clipboard.
         */
        copyJsonBtn.addEventListener('click', () => {
            if (currentParsedData) {
                try {
                    let jsonString;
                    if (currentDataType === 'json') {
                        jsonString = JSON.stringify(currentParsedData, null, 2);
                    } else if (currentDataType === 'xml') {
                        const jsonObject = xmlToJson(currentParsedData);
                        jsonString = JSON.stringify(jsonObject, null, 2);
                    }
                    copyToClipboard(jsonString);
                } catch (e) {
                    showMessage('Error copying JSON to clipboard.', 'error');
                    console.error(e);
                }
            } else {
                showMessage('No data to copy as JSON. Please process data first.', 'error');
            }
        });

        /**
         * Helper function to convert XML DOM to a basic JSON object.
         * This is a simplified conversion and might not represent complex XML perfectly.
         * @param {Element} xml The XML DOM element.
         * @returns {object} The resulting JSON object.
         */
        function xmlToJson(xml) {
            let obj = {};

            if (xml.nodeType === Node.ELEMENT_NODE) { // element
                // attributes
                if (xml.hasAttributes()) {
                    for (let i = 0; i < xml.attributes.length; i++) {
                        let attribute = xml.attributes.item(i);
                        obj["@" + attribute.nodeName] = attribute.nodeValue;
                    }
                }

                // child nodes
                if (xml.hasChildNodes()) {
                    for (let i = 0; i < xml.childNodes.length; i++) {
                        let item = xml.childNodes.item(i);
                        let nodeName = item.nodeName;
                        if (nodeName === "#text") {
                            // Trim whitespace for text content
                            let textContent = item.nodeValue.trim();
                            if (textContent) {
                                // If the element has text content AND child elements, put text content under a special key
                                if (Object.keys(obj).length > 0 && xml.children.length > 0) {
                                    obj["#text"] = textContent;
                                } else { // Otherwise, if it's just text or text + attributes, make it the main value
                                    return textContent;
                                }
                            }
                        } else if (item.nodeType === Node.ELEMENT_NODE) {
                            if (typeof obj[nodeName] == "undefined") {
                                obj[nodeName] = xmlToJson(item);
                            } else {
                                if (typeof obj[nodeName].push == "undefined") {
                                    let old = obj[nodeName];
                                    obj[nodeName] = [];
                                    obj[nodeName].push(old);
                                }
                                obj[nodeName].push(xmlToJson(item));
                            }
                        }
                    }
                }
            }
            return obj;
        }


        /**
         * Reconstructs XML from the currentParsedData and triggers download.
         */
        downloadXmlBtn.addEventListener('click', () => {
            if (currentParsedData) {
                try {
                    let xmlString;
                    if (currentDataType === 'xml') {
                        const serializer = new XMLSerializer();
                        xmlString = serializer.serializeToString(currentParsedData);
                    } else if (currentDataType === 'json') {
                        // Convert JSON to XML (simplified approach, might not cover all JSON structures)
                        const xmlDoc = document.implementation.createDocument(null, '', null);
                        const rootElement = jsonToXml(currentParsedData, xmlDoc, 'root'); // Assuming 'root' as a default root tag
                        xmlDoc.appendChild(rootElement);
                        const serializer = new XMLSerializer();
                        xmlString = serializer.serializeToString(xmlDoc);
                    }
                    downloadFile(xmlString, 'edited.xml', 'application/xml');
                } catch (e) {
                    showMessage('Error converting data back to XML for download.', 'error');
                    console.error(e);
                }
            }
            else {
                showMessage('No data to download as XML. Please process data first.', 'error');
            }
        });

        /**
         * Copies the current data as XML to the clipboard.
         */
        copyXmlBtn.addEventListener('click', () => {
            if (currentParsedData) {
                try {
                    let xmlString;
                    if (currentDataType === 'xml') {
                        const serializer = new XMLSerializer();
                        xmlString = serializer.serializeToString(currentParsedData);
                    } else if (currentDataType === 'json') {
                        const xmlDoc = document.implementation.createDocument(null, '', null);
                        const rootElement = jsonToXml(currentParsedData, xmlDoc, 'root');
                        xmlDoc.appendChild(rootElement);
                        const serializer = new XMLSerializer();
                        xmlString = serializer.serializeToString(xmlDoc);
                    }
                    copyToClipboard(xmlString);
                } catch (e) {
                    showMessage('Error copying XML to clipboard.', 'error');
                    console.error(e);
                }
            } else {
                showMessage('No data to copy as XML. Please process data first.', 'error');
            }
        });

        // Initialize the form display on load
        window.onload = clearForm;

        /**
         * Helper function to convert a JSON object to XML DOM elements.
         * This is a simplified conversion and might not represent complex JSON perfectly.
         * @param {object | array | string | number | boolean} obj The JSON value.
         * @param {Document} doc The XML document.
         * @param {string} tagName The tag name for the current element.
         * @returns {Element} The created XML element.
         */
        function jsonToXml(obj, doc, tagName) {
            const element = doc.createElement(tagName);

            if (typeof obj === 'object' && obj !== null) {
                if (Array.isArray(obj)) {
                    obj.forEach(item => {
                        // For array items, use the same tagName as the parent, or a generic 'item'
                        element.appendChild(jsonToXml(item, doc, tagName));
                    });
                } else {
                    for (const key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) {
                            const value = obj[key];
                            if (key.startsWith('@')) { // Treat as attribute
                                element.setAttribute(key.substring(1), value);
                            } else if (key === '#text') { // Treat as text content
                                element.textContent = value;
                            } else {
                                if (typeof value === 'object' && value !== null) {
                                    if (Array.isArray(value)) {
                                        // If it's an array, create multiple elements with the same tag name
                                        value.forEach(item => {
                                            element.appendChild(jsonToXml(item, doc, key));
                                        });
                                    } else {
                                        element.appendChild(jsonToXml(value, doc, key));
                                    }
                                } else {
                                    // Primitive values become child elements with their key as tag name
                                    const childElement = doc.createElement(key);
                                    childElement.textContent = value;
                                    element.appendChild(childElement);
                                }
                            }
                        }
                    }
                }
            } else {
                element.textContent = obj; // Primitive value becomes text content of the element
            }
            return element;
        }

    </script>
</body>
</html>
